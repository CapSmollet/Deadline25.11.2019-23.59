/*
Напишите программу, находящую натуральные корни уравнения
2020X +2021Y=78487894
эффективным перебором. В комментариях напишите, почему перебор - эффективный
 */
#include <iostream>

using namespace std;

const int EPS = 78487894;

int x = 1, ans, k, y, x0, y0, x1, y1;

int main() {
    int n = EPS;
    while (x * 2020 + 2021 < n)
    {
        int l = 0, r = 40000;
        while (r - l > 1)
        {
            y = (l + r) / 2;
            if (x * 2020 + 2021 * y < n)
            {
                l = y;
            }
            else
            {
                r = y;
            }
        }
        if (x * 2020 + 2021 * r == n)
        {
            ans++;
            cout << x << ' ' <<  r << '\n';
            if (k == 0)
            {
                x0 = x;
                y0 = r;
                k++;
            }
            else
            {
                x1 = x;
                y1 = y;
                break;
            }
        }
        x++;
    }
    //В принципе можно угадать первые корни, но как по мне это читерство
    int s1 = 2021, s2 = -2020;
    while (y + s2 > 0)
    {
        x += s1;
        y += s2;
        cout << x << ' ' << y << '\n';
    }
    return 0;
}
//Данный алгоритм эффективен т.к первые два корня он находит за O(n * log(n)), а затем определяет завимисимость и идёт по ней пока корни натуральный
/*1683 37154
3704 35134
5725 33114
7746 31094
9767 29074
11788 27054
13809 25034
15830 23014
17851 20994
19872 18974
21893 16954
23914 14934
25935 12914
27956 10894
29977 8874
31998 6854
34019 4834
36040 2814
38061 794*/